本章中研究的结构仅依赖于第一节中概述的第一和第三原理。也就是说，使用**精确的数学定义**并给出**严格的证明**，但将不需要依赖任何未经证明的计算假设。

从本章开始，我们将通过涉及随机化算法的概率实验来定义安全性并分析方案。我们将先简要讨论适用于密码学应用的随机数生成问题，再回归密码学本身的探讨。

---

>首先的问题是：如何在一个确定性的机器（计算机）上生成真正的随机数？

简化假设：通信各方拥有无限供应的独立、无偏（即均匀分布）的比特流。

现代随机数生成分为两个步骤：
1. 首先，收集一个高熵数据的“池 (pool)”。（对于我们的目的而言，不需要熵的正式定义，只要把熵看作是**不可预测性**的度量即可。高熵性：不可预测性、无规律性、不可复现性）
2. 接下来，处理这些高熵数据以产生一系列几乎独立且无偏的比特。这第二个步骤是必要的，因为高熵数据并不一定是均匀分布的。

如何保证数据的高熵性？不可预测的数据来源是什么？
- **软件/外部来源**：利用系统的不确定性。这类来源基于计算机系统运行中的随机波动，虽熵值略低于物理熵源，但易集成，适合通用场景。例如，你敲击键盘的精确时间间隔、鼠标移动的轨迹、硬盘读写的微小延迟、网络数据包到达的抖动。这些对攻击者来说很难预测。
- **硬件/物理来源**：利用微观物理现象，物理熵源是硬件级，熵值最高。这类来源基于微观粒子的随机运动，完全不受软件逻辑控制，是最可靠的熵源。例如，电子元件的热噪声（Thermal noise）。Intel 等厂商直接在 CPU 里集成了这种电路（如指令 RDRAND），这种方式速度更快、质量更高。

如何平滑数据？
      **为什么需要这一步？** 收集来的数据虽然不可预测（高熵），但不一定均匀。比如某个传感器可能输出“1”的概率（70%）比“0”的概率（30%）高。这种有偏（Biased）的数据不能直接用于加密。
       **冯·诺依曼提取器**（Von Neumann Extractor）：文中提到的“成对处理”的方法就是著名的
           原理：
            遇到 `00` 或 `11` $\rightarrow$ 丢弃（因为概率不一定相等，且包含的信息少）。
            遇到 `10` $\rightarrow$ 输出 `0`。
            遇到 `01` $\rightarrow$ 输出 `1`。
          数学逻辑：无论 1 的概率 $p$ 是多少，`10` 的概率是 $p(1-p)$，`01` 的概率是 $(1-p)p$。两者完全相等！这样就把不均匀的输入变成了均匀的输出（50% 对 50%）。

必须小心地生成随机比特，使用糟糕的随机数生成器往往会让一个优秀的加密系统易受攻击。应该使用专为**加密用途 (cryptographic use)** 设计的随机数生成器。
- **普通随机数生成器 (PRNG)**：如 C 语言的 rand()、Java 的 Random。它们的设计目的是为了模拟、游戏或统计采样，速度快但**可预测**。如果你知道它生成的某几个数，就能推算出后面所有的数。
    
- **加密安全随机数生成器 (CSPRNG)**：如 /dev/urandom (Linux)、CryptGenRandom (Windows)。它们专为安全设计，无法通过历史数据预测未来数据。
    
- **后果**：在生成密钥、初始化向量（IV）时，如果使用了 rand() 这种不安全的函数，黑客可以轻松预测你的密钥，从而解密所有数据。**这被称为“灾难性的后果”。**

---
# 2.1 定义

#### 1. 加密方案的形式化定义 
这里给出了严格的计算机科学定义：
*   **Gen (Key Generation)**: 必须是随机的。如果密钥生成是确定的（比如总是输出 12345），那就不安全了。
*   **Enc (Encryption)**: 这里引入了一个现代概念——加密可以是**概率性**的。
    *   *传统加密（如移位密码、AES-ECB）*是确定性的：同样的 $M$ 和 $K$ 永远得到同样的 $C$。
    *   *现代加密* 通常引入随机数（IV 或 Nonce），使得同样的 $M$ 和 $K$ 每次加密得到**不同**的 $C$。这对防御重放攻击和模式分析至关重要。
*   **Dec (Decryption)**: 必须是确定性的。解密不能靠运气，必须 100% 还原消息（即“完美正确性”）。

#### 2. 三个随机变量 (K, M, C)
这是理解后续“完美保密性”的关键：
*   **$K$ (密钥)**: 它的随机性来自于算法 Gen。通常假设它是**均匀分布**的（每个密钥被选中的概率相等）。
*   **$M$ (消息)**: 它的随机性来自于**现实世界/对手的知识**。
    *   这往往是初学者最难理解的。为什么消息是随机的？这代表了对手的**先验知识**。
    *   比如在战争中，对手知道你有 70% 的可能进攻，30% 的可能撤退。这就是 $M$ 的分布。
    * **消息的概率分布不是由加密方案本身决定的，而是反映了通信方发送不同消息的可能性**
*   **$C$ (密文)**: 它是由 $K$ 和 $M$ 计算出来的结果。

**关键点：$K$ 和 $M$ 是独立的。**
这意味着你决定说什么话（$M$），和你口袋里装着什么密钥（$K$），这两件事毫无关系。当事方**通信的内容必须与他们共享的密钥无关**。

---

**例 2.1**
我们通过移位密码（Shift Cipher）的一个简单例子来进行说明。在这里，根据定义，我们有 $\mathcal{K} = \{0, \dots, 25\}$，且对于每个 $k \in \mathcal{K}$，$\Pr[K = k] = 1/26$。
假设给定的 $\mathcal{M}$ 上的分布如下：
$$ \Pr[M = \text{a}] = 0.7 \quad \text{和} \quad \Pr[M = \text{z}] = 0.3 $$
密文是 B 的概率是多少？只有两种情况会发生这种情况：要么 $M = \text{a}$ 且 $K = 1$，要么 $M = \text{z}$ 且 $K = 2$。由于 $M$ 和 $K$ 的独立性，我们要：
$$ \Pr[M = \text{a} \wedge K = 1] = \Pr[M = \text{a}] \cdot \Pr[K = 1] = 0.7 \cdot (1/26) $$
同理，$\Pr[M = \text{z} \wedge K = 2] = 0.3 \cdot (1/26)$。因此，
$$ \Pr[C = \text{B}] = \Pr[M = \text{a} \wedge K = 1] + \Pr[M = \text{z} \wedge K = 2] $$
$$ = 0.7 \cdot (1/26) + 0.3 \cdot (1/26) = 1/26 $$

我们也可以计算条件概率。例如，在观察到密文 B 的情况下，消息是 a 的概率是多少？利用贝叶斯定理（定理 A.8），我们有：
$$ \Pr[M = \text{a} \mid C = \text{B}] = \frac{\Pr[C = \text{B} \mid M = \text{a}] \cdot \Pr[M = \text{a}]}{\Pr[C = \text{B}]} $$
$$ = \frac{\Pr[C = \text{B} \mid M = \text{a}] \cdot 0.7}{1/26} $$
注意 $\Pr[C = \text{B} \mid M = \text{a}] = 1/26$，因为如果 $M = \text{a}$，那么发生 $C = \text{B}$ 的唯一方式是 $K = 1$（其发生概率为 1/26）。我们得出结论：
$$ \Pr[M = \text{a} \mid C = \text{B}] = 0.7 $$

---
上面这个例子的描述可能不是那么生动，我们换一种说法。
### 1. 案情背景（已知条件）

假设你是一个黑客，你正在监听两个人的通信。
*   **嫌疑人**：只可能发两个字母，要么是 **'a'**，要么是 **'z'**。
*   **情报（先验概率）**：根据你之前的长期观察，你知道他们发 **'a'** 的概率很大（**70%**），发 **'z'** 的概率很小（**30%**）。
*   **加密工具**：移位密码（凯撒密码），密钥是 0 到 25 之间随便选的一个数字，每个数字被选中的概率都是 **1/26**。

### 2. 案发经过（数学计算过程）

突然，你截获了一个密文：**'B'**。
现在你要开始推理工了：**“这个 'B' 到底是原本的 'a' 变来的，还是原本的 'z' 变来的？”**

#### 第一步：我们要搞清楚，什么情况下会产生 'B'？
移位密码的规则是：明文 + 密钥 = 密文。

*   **情况 1：原本是 'a'**
    *   如果不加密，'a' 就是 'a'。
    *   要变成 'B'，密钥必须是 **1**（往后移1位）。
*   **情况 2：原本是 'z'**
    *   要变成 'B'，密钥必须是 **2**（'z' 往后移1位是 'a'，移2位是 'b'，原文既然用大写B表示密文，逻辑是一样的）。

#### 第二步：计算这两种情况发生的“可能性”
*   **发生“情况 1”的概率** = (发 'a' 的概率) × (选到密钥 1 的概率)
    $$ 0.7 \times \frac{1}{26} = \frac{0.7}{26} $$
*   **发生“情况 2”的概率** = (发 'z' 的概率) × (选到密钥 2 的概率)
    $$ 0.3 \times \frac{1}{26} = \frac{0.3}{26} $$

#### 第三步：密文 'B' 出现的总概率是多少？
不管原来是 'a' 还是 'z'，反正只要能变出 'B' 都在这了。
总概率 = 情况1 + 情况2
$$ \frac{0.7}{26} + \frac{0.3}{26} = \frac{1}{26} $$
*(注意：这正好等于 1/26。这意味着在移位密码里，出现任何一个密文字母的概率都是 1/26，完全随机。)*

#### 第四步：关键推理（贝叶斯推断）
现在你手拿着密文 'B'，你问自己：**“它是 'a' 的概率是多少？”**

这就像在算比重：在所有能产生 'B' 的情况中，“原本是 'a'” 占了多大的比例？

$$ \text{是'a'的概率} = \frac{\text{情况1的概率}}{\text{总概率}} = \frac{0.7/26}{1/26} = 0.7 $$

### 3. 这个例子说明了什么？（核心结论）

请对比两个数据：

1.  **截获密文之前**：你觉得明文是 'a' 的概率是 **70%**（这是你的先验知识）。
2.  **截获密文 'B' 之后**：你算了一通，发现明文是 'a' 的概率依然是 **70%**。

**结论：你截获的这个密文 'B'，就是个寂寞！**

*   这个密文没有给你提供任何**新信息**。
*   它没有让你排除任何错误答案。
*   它没有让你对正确答案更有信心。
*   你看了密文和没看密文，对明文的判断一模一样。

这就是密码学中至高无上的概念：**完美保密性 (Perfect Secrecy)**。

**这个例子想告诉你：**
如果一个加密方案是“完美”的，那么**密文分布**与**明文分布**是**独立**的。黑客拿着密文去推导明文，就像拿着一张白纸去推导明文一样，概率完全不会变。移位密码（在一次性密钥的前提下）就展示了这种数学上的完美平衡。

---
### 反例
在这里我们举一个反例，没有实现完美保密。这是之前讨论的**例 2.1** 的延续，即**例 2.2**。

**例 2.2**
再次考虑移位密码，但在消息空间 $\mathcal{M}$ 上有以下分布：
$$ \Pr[M = \text{kim}] = 0.5, \quad \Pr[M = \text{ann}] = 0.2, \quad \Pr[M = \text{boo}] = 0.3 $$
（注：即发送 kim 的概率是 50%，ann 是 20%，boo 是 30%）

密文 $C = \text{DQQ}$ 出现的概率是多少？
这个密文出现的唯一方式是：要么 $M = \text{ann}$ 且密钥 $K = 3$；要么 $M = \text{boo}$ 且密钥 $K = 2$。这种情况发生的概率为：
$$ 0.2 \cdot (1/26) + 0.3 \cdot (1/26) = 1/52 $$

我们也可以计算在观察到密文为 DQQ 的条件下，被加密的消息是 ann 的概率。像上面一样使用贝叶斯定理进行计算，得出：
$$ \Pr[M = \text{ann} \mid C = \text{DQQ}] = 0.4 $$

---

为了理解这个例子为什么说明了**不安全**，我们需要再次扮演侦探。

#### 1. 案发前（先验概率）
你作为监听者，在截获密文之前，心里有一个预测：
*   嫌疑人发送 **"kim"** 的可能性最大（**50%**）。
*   发送 **"ann"** 的可能性较小（**20%**）。
*   发送 **"boo"** 的可能性一般（**30%**）。

#### 2. 案发经过
你截获了密文：**"DQQ"**。
现在你开始分析，谁能生成这个密文？

*   **嫌疑人 "kim"**：
    *   $k$ 到 $D$ 需要移位 -7 (或+19)。
    *   $i$ 到 $Q$ 需要移位 +8。
    *   移位数不一致！所以**绝对不可能是 "kim"**。
    *   *侦探发现：最大的嫌疑人被直接排除了！*

*   **嫌疑人 "ann"**：
    *   $a \to D$ (+3)
    *   $n \to Q$ (+3)
    *   $n \to Q$ (+3)
    *   一致！如果是 "ann" 并且密钥是 **3**，就能生成 DQQ。

*   **嫌疑人 "boo"**：
    *   $b \to D$ (+2)
    *   $o \to Q$ (+2)
    *   $o \to Q$ (+2)
    *   一致！如果是 "boo" 并且密钥是 **2**，就能生成 DQQ。

#### 3. 重新评估（后验概率计算）
现在只剩下两个嫌疑人："ann" 和 "boo"。之前的 "kim" 已经出局了。
我们要重新计算由于 "kim" 出局后，剩下两人的嫌疑比例。

*   **"ann" 贡献的权重**：$0.2 \times (1/26)$
*   **"boo" 贡献的权重**：$0.3 \times (1/26)$
*   **总权重**：$(0.2+0.3) \times (1/26) = 0.5 \times (1/26)$

现在计算 "ann" 的真实嫌疑（后验概率）：
$$ \text{是ann的概率} = \frac{\text{ann的权重}}{\text{总权重}} = \frac{0.2}{0.5} = 0.4 \text{ (即 40\%)} $$

### 4. 结论：这个例子说明了什么？

这个例子展示了**完美保密性的破坏（泄露信息）**。

请对比数据：
1.  **截获密文前**：你认为消息是 "ann" 的概率是 **20%** ($0.2$)。
2.  **截获密文后**：你计算出消息是 "ann" 的概率变成了 **40%** ($0.4$)。

**核心知识点**：
因为 **后验概率 (0.4) $\neq$ 先验概率 (0.2)**，所以**该加密方案在这个分布下不具备完美保密性**。

**这次加密泄露了什么信息？**
1.  它泄露了消息**绝对不是 "kim"**。
2.  它让攻击者对消息是 "ann" 的信心**翻倍**了（从 20% 涨到了 40%）。

### 总结
*   **例 2.1** 告诉我们在特定条件下（如一次性密钥），密文不泄露任何信息（概率不变）。
*   **例 2.2** 告诉我们在一般情况下（特别是消息有特定结构，或者密钥空间不够大时），密文会泄露明文的信息，导致攻击者可以通过密文修正对明文的猜测（概率改变）。

---
## 完美保密

什么是完美保密，通过上述的例子我们可以定义出完美保密的概念。

前提假设，我们要想象这样一个对手（Adversary）, 这是**Kerckhoffs 原则** 的极端版：
1.  他知道消息 $M$ 的概率分布；也就是说，对手知道不同消息被发送的可能性大小。
2.  对手也知道所使用的加密方案（算法）。
3.  对手甚至可以截获密文，对手唯一不知道的，是通信双方共享的密钥。
在这种极其不利的情况下，如果对手依然无法破解，那才是真正的安全。

一条消息由其中一个诚实方选出并加密，生成的密文被传输给另一方。对手可以窃听双方的通信，从而观测到这个密文。（也就是说，这是一种**唯密文攻击**，攻击者只能看到一个单一的密文。）

完美保密性（通常指一次性密码本 One-Time Pad）是针对**一次**加密而言的。如果你用同一个密钥加密多条消息（Many-time pad），完美保密性就会失效。

如果要让一个方案是**完美保密**的，那么观测到这个密文不应该对对手关于“实际发送了哪条消息”的知识产生任何影响；

换句话说，在观测到密文的条件下，某条消息 $m \in \mathcal{M}$ 被发送的**后验概率 (a posteriori probability)**，应该与该消息被发送的**先验概率 (a priori probability)** 没有任何区别。

这意味着密文没有泄露关于明文的任何信息，对手对于被加密的明文可谓是一无所知（绝对没有学到任何新东西）。

一个完美的加密系统，不是让对手“很难算出来”，而是让对手**即便拥有无限的计算能力，算出结果的概率也和瞎猜一样**。这在数学上被称为**信息论安全 (Information-Theoretic Security)**。

---
### 完美保密的数学定义与反例

**定义 2.3**
一个具有消息空间 $\mathcal{M}$ 的加密方案 $(\mathsf{Gen}, \mathsf{Enc}, \mathsf{Dec})$ 是**完美保密 (perfectly secret)** 的，如果对于 $\mathcal{M}$ 上的每一个概率分布，每一个消息 $m \in \mathcal{M}$，以及每一个满足 $\Pr[C=c] > 0$ 的密文 $c \in \mathcal{C}$，都有：
$$ \Pr[M=m \mid C=c] = \Pr[M=m] $$
（注：要求 $\Pr[C=c] > 0$ 是一个技术性条件，用于防止对零概率事件进行条件概率计算。）

**例 2.4**
我们要证明，当移位密码（Shift Cipher）用于由所有**双字符**明文组成的消息空间 $\mathcal{M}$ 时，它**不是**完美保密的。为此，我们利用定义 2.3，并展示 $\mathcal{M}$ 上的一个概率分布，使得对于某个消息 $m$ 和密文 $c$：
$$ \Pr[M=m \mid C=c] \neq \Pr[M=m] $$
这样的分布有很多，我们选一个简单的：假设消息要么是 **aa**，要么是 **ab**，且概率各为一半。设 $m = \text{ab}$ 且 $c = \text{XX}$。
那么显然 $\Pr[M=\text{ab} \mid C=\text{XX}] = 0$，因为 **ab** 加密后绝不可能产生 **XX**。但是 $\Pr[M=\text{ab}] = 1/2$。

#### 2. 详细讲解

**关于定义 2.3：**
这就是我们在上一节讨论的“后验概率等于先验概率”。
*   **直觉**：不管你截获了什么密文 $c$，你对明文是 $m$ 的猜测概率完全没变。密文没给你任何提示。

**关于例 2.4（反例）：**
这个例子非常敏锐地指出了为什么简单的移位密码在加密**多于一个字母**时就不安全了（如果只用一个密钥）。

*   **场景设定**：
    *   你要么发 "aa"（概率 50%），要么发 "ab"（概率 50%）。
    *   **先验概率**：$\Pr[M=\text{ab}] = 0.5$。
*   **攻击过程**：
    *   你截获了密文 **"XX"**。
    *   对于移位密码，密钥 $k$ 对整条消息是固定的。
        *   如果是 "aa"：这意味着 $a \to X$，那么第二个 $a$ 也必须 $\to X$。结果是 "XX"。这完全可能。
        *   如果是 "ab"：这意味着 $a \to X$。因为 $b$ 是 $a$ 的下一个字母，所以 $b$ 必须变成 $X$ 的下一个字母 $Y$。结果应该是 "XY"。
    *   **结论**：用移位密码，"ab" **绝对不可能** 被加密成 "XX"。
*   **结果**：
    *   看到密文 "XX" 后，你立刻知道明文**绝不是** "ab"。
    *   **后验概率**：$\Pr[M=\text{ab} \mid C=\text{XX}] = 0$。
    *   因为 $0 \neq 0.5$，所以完美保密性被打破了。

---

### 第二部分：等价表述 (Equivalent Formulation)

#### 1. 中文翻译

我们现在给出完美保密性的一个等价表述。这个表述通过要求**密文的分布不依赖于明文**来定义完美保密性。即，对于任意两个消息 $m, m' \in \mathcal{M}$，加密 $m$ 时的密文分布应该与加密 $m'$ 时的密文分布完全相同。
也就是说，对于每一个 $m, m' \in \mathcal{M}$ 和每一个 $c \in \mathcal{C}$，我们有：
$$ \Pr[\mathsf{Enc}_K(m) = c] = \Pr[\mathsf{Enc}_K(m') = c] \quad \text{(公式 2.1)} $$
（这里的概率是基于 $K$ 的选择以及 $\mathsf{Enc}$ 的任何随机性。）
注意，上述概率**仅依赖于加密方案**，而完全不涉及 $\mathcal{M}$ 上的任何底层分布。上述条件意味着密文不包含关于明文的任何信息，并且区分 $m$ 的加密结果和 $m'$ 的加密结果是不可能的，因为这两种情况下的密文分布是相同的。

**引理 2.5**
一个消息空间为 $\mathcal{M}$ 的加密方案 $(\mathsf{Gen}, \mathsf{Enc}, \mathsf{Dec})$ 是完美保密的，**当且仅当 (if and only if)** 公式 (2.1) 对每一个 $m, m' \in \mathcal{M}$ 和每一个 $c \in \mathcal{C}$ 都成立。

#### 2. 详细讲解

这是完美保密性的另一种看法，在做数学证明时通常比原始定义更好用。

*   **原始定义**：$\Pr[M|C] = \Pr[M]$ （从攻击者角度：我看密文前后想法不变）。
*   **等价定义**：$\Pr[Enc(m)=c] = \Pr[Enc(m')=c]$ （从上帝视角：不管加密哪个消息，产生同一个密文的概率是一样的）。

**直观理解**：
想象你有两封信，一封写着“进攻”，一封写着“撤退”。
如果这是完美保密的，那么：
*   “进攻”被加密成乱码 "X8jK" 的概率是 0.001%。
*   “撤退”被加密成乱码 "X8jK" 的概率也必须是 0.001%。
如果概率不同（比如“撤退”变成 "X8jK" 的概率更大），那攻击者看到 "X8jK" 就会倾向于猜“撤退”。只有概率完全相等，攻击者才无法区分。

---

### 第三部分：引理 2.5 的证明

#### 1. 中文翻译

**证明**
证明是很直接的，但我们详细过一遍。
关键的观察是，对于任何方案、$\mathcal{M}$ 上的任何分布、任何满足 $\Pr[M=m]>0$ 的 $m \in \mathcal{M}$ 以及任何 $c \in \mathcal{C}$，我们有：
$$ \Pr[C=c \mid M=m] = \Pr[\mathsf{Enc}_K(M)=c \mid M=m] $$
$$ = \Pr[\mathsf{Enc}_K(m)=c \mid M=m] $$
$$ = \Pr[\mathsf{Enc}_K(m)=c] \quad \text{(公式 2.2)} $$
其中第一个等式是根据随机变量 $C$ 的定义，第二个是因为我们以 $M=m$ 为条件，第三个是因为 $K$ 是**独立于** $M$ 的。
我们也利用这一事实：对于任何满足 $\Pr[C=c]>0$ 的 $c \in \mathcal{C}$，我们有（贝叶斯定理）：
$$ \Pr[M=m \mid C=c] \cdot \Pr[C=c] = \Pr[C=c \mid M=m] \cdot \Pr[M=m] \quad \text{(公式 2.3)} $$

**第一步：假设完美保密 $\Rightarrow$ 推导公式 (2.1)**
取 $\mathcal{M}$ 上的均匀分布。如果方案是完美保密的，那么 $\Pr[M=m \mid C=c] = \Pr[M=m]$。因此公式 (2.3) 意味着 $\Pr[C=c \mid M=m] = \Pr[C=c]$。
由于 $m$ 和 $c$ 是任意的，这表明对于每一个 $m, m' \in \mathcal{M}$ 和每一个 $c \in \mathcal{C}$：
$$ \Pr[\mathsf{Enc}_K(m)=c] = \Pr[C=c \mid M=m] = \Pr[C=c] = \Pr[C=c \mid M=m'] = \Pr[\mathsf{Enc}_K(m')=c] $$
（使用公式 2.2），从而证明了引理的一个方向。

**第二步：假设公式 (2.1) $\Rightarrow$ 推导完美保密**
反之，假设公式 (2.1) 对每一个 $m, m' \in \mathcal{M}$ 和每一个 $c \in \mathcal{C}$ 都成立。
固定 $\mathcal{M}$ 上的某个分布，一个消息 $m \in \mathcal{M}$ 和一个满足 $\Pr[C=c]>0$ 的密文 $c \in \mathcal{C}$。
（如果 $\Pr[M=m]=0$，则显然成立，略过。）
假设 $\Pr[M=m] > 0$。对于 $c \in \mathcal{C}$，定义 $p_c \stackrel{\text{def}}{=} \Pr[\mathsf{Enc}_K(m)=c]$。
公式 (2.1) 和 (2.2) 意味着对于每一个 $m' \in \mathcal{M}$，$\Pr[C=c \mid M=m'] = p_c$。
所以（全概率公式）：
$$ \Pr[C=c] = \sum_{m' \in \mathcal{M}} \Pr[C=c \mid M=m'] \cdot \Pr[M=m'] $$
$$ = \sum_{m' \in \mathcal{M}} p_c \cdot \Pr[M=m'] = p_c \cdot 1 = p_c $$
$$ = \Pr[C=c \mid M=m] $$
最后，公式 (2.3) 意味着 $\Pr[M=m \mid C=c] = \Pr[M=m]$，所以该方案是完美保密的。

#### 2. 详细讲解与逻辑梳理

这个证明看起来公式很多，其实核心逻辑很简单，就是利用**贝叶斯定理**在两个定义之间来回推导。

**核心公式回顾**：
1.  **公式 2.2**：告诉我们 $\Pr[C=c|M=m]$ 其实就是 $\Pr[Enc_K(m)=c]$。这很重要，因为它把条件概率转化为了加密算法本身的概率（去掉了条件 $M=m$，因为密钥和消息是独立的）。
2.  **公式 2.3**：这就是贝叶斯公式的变形形式：$P(A|B)P(B) = P(B|A)P(A)$。

**逻辑流向**：

*   **方向 1：完美保密 $\Rightarrow$ 密文分布相同**
    1.  如果是完美保密的，那么 $M$ 和 $C$ 是独立的（后验=先验）。
    2.  这意味着 $\Pr[C=c \mid M=m]$ 其实就等于 $\Pr[C=c]$（不管 $m$ 是什么，生成 $c$ 的概率是一个常数）。
    3.  既然不管 $m$ 是什么概率都一样，那么 $\Pr[\mathsf{Enc}(m)=c]$ 和 $\Pr[\mathsf{Enc}(m')=c]$ 自然也就相等了。

*   **方向 2：密文分布相同 $\Rightarrow$ 完美保密**
    1.  假设不管加密什么消息 $m$，生成密文 $c$ 的概率都是固定的常数 $p_c$。
    2.  那么，密文 $c$ 出现的**总概率** $\Pr[C=c]$ 是多少？就是把所有情况加起来。既然每种情况概率都是 $p_c$，加权平均后总概率还是 $p_c$。
    3.  现在回到贝叶斯公式：
        $$ \Pr[M|C] = \frac{\Pr[C|M] \cdot \Pr[M]}{\Pr[C]} $$
    4.  分子里的 $\Pr[C|M]$ 是 $p_c$。分母 $\Pr[C]$ 也是 $p_c$。
    5.  它们消掉了！
    6.  结果：$\Pr[M|C] = \Pr[M]$。得证。

**总结**：
这一页展示了数学在密码学中的严谨性。它证明了“完美保密性”不仅意味着攻击者猜不透（定义2.3），也意味着加密算法本身对于任何输入消息，产生相同密文的概率必须完全一致（引理2.5）。后者在设计系统时更容易验证。

### 完美保密的另一个等价定义
#### 1. 核心概念：不可区分性实验 ($\mathsf{PrivK}^{\mathsf{eav}}_{\mathcal{A}, \Pi}$)
这是一个思想实验，用来衡量加密方案是否泄露了信息。
*   **角色**：
    *   **挑战者（Challenger）**：拥有密钥，负责加密。
    *   **敌手（Adversary, $\mathcal{A}$）**：试图破解系统。在这里，敌手被赋予了很强的能力——**选择明文攻击（CPA）的雏形**（虽然这里只是一次性的选择，且针对被动攻击）。
*   **流程**：
    1.  敌手挑选两句他觉得最容易混淆或者最想区分的话（$m_0, m_1$）。
    2.  挑战者抛硬币（$b$），随机挑一句加密，把密文扔给敌手。
    3.  敌手猜是哪一句（$b'$）。
*   **直观理解**：如果加密方案是完美的，敌手看到密文后，应该完全无法判断这串乱码是来自 $m_0$ 还是 $m_1$。他只能瞎猜，瞎猜对的概率就是 $50\%$（即 $1/2$）。

#### 2. 完美不可区分性 (Definition 2.6)
*   **定义**：对于**任何**敌手，其在实验中获胜（猜对）的概率都严格等于 $1/2$。
*   **公式**：$\Pr [\mathsf{PrivK}^{\mathsf{eav}}_{\mathcal{A}, \Pi} = 1] = 1/2$。
*   **重要性**：这并不意味着敌手不能攻击，而是说敌手即使拿到密文，其猜测准确率和没拿到密文时（盲猜）是一样的。这说明密文没有泄露关于明文的**任何**信息。

#### 3. 与香农完美保密（Perfect Secrecy）的关系 (Lemma 2.7)
*   材料中提到这两者是**等价的**。
    *   **香农定义**（概率论角度）：$\Pr[M=m | C=c] = \Pr[M=m]$。即拥有密文不会改变对明文概率的判断。
    *   **不可区分性定义**（计算/博弈角度）：敌手无法区分两个明文的密文。
*   **为什么需要新定义？** 虽然它们在“完美”这个层面上等价，但“不可区分性”这个框架更容易扩展到后续的**计算安全性（Computational Security）**。在计算安全性中，我们不再要求概率**等于** $1/2$，而是要求**极其接近** $1/2$（即优势可忽略），这种微小的放宽是现代密码学（如 AES, RSA）能实际应用的基础。

#### 4. 维吉尼亚密码的反例分析 (Example 2.8)
作者用维吉尼亚密码做例子，证明它达不到“完美不可区分性”。

*   **设定**：
    *   消息长度：2个字符。
    *   密钥长度（周期）：可能是1（类似凯撒密码），也可能是2。
*   **敌手的策略（攻击手法）**：
    *   敌手利用了**统计模式的残留**。
    *   $m_0 = \text{aa}$：因为两个明文符号相同，如果密钥周期是1（或者周期是2但两个密钥字符相同），密文的两个字符必然相同（如 "KK"）。
    *   $m_1 = \text{ab}$：因为明文不同，要生成相同的密文字符，密钥必须恰好弥补明文的差值（极其罕见）。
*   **判断依据**：敌手只看密文的两个字是否一样 ($c_1 = c_2$)。
    *   如果一样，极大可能是 `aa` 被加密了。
    *   如果不一样，极大可能是 `ab` 被加密了。
*   **计算结果**：
    *   如果不看密文，猜对概率是 $0.5$。
    *   使用了这个策略，猜对概率变成了 $0.75$。
    *   因为 $0.75 > 0.5$，所以敌手有了**优势（Advantage）**，证明维吉尼亚密码在这种配置下**不具备**完美不可区分性。

# 2.2 一次一密（The One-Time Pad）
## 2.2.1 概念

1917 Vernam，为一次性密码本的完美保密加密方案申请了专利。申请专利的时候，还没有关于它事完美保密的证明。

在一次性密码本加密方案中，密钥是一个**与消息长度相同**的**均匀随机字符串**，密文是通过**简单地将密钥和消息进行异或运算计算**出来的.

## 2.2.2 一次一密的优点和局限

优点：一次一密的优点在于其能够实现完美保密，哪怕敌手看到密文c，他对明文是什么的猜测概率和没看到密文c时的概率保持一致，即敌手无法从密文中获取任何有用的信息。

局限：一次一密的局限不仅局限于自身，而是任何完美保密的方案必须具备至少于消息空间等大的密钥空间。对于一次一密简单来说就是密钥的长度要与消息等长，一次一密已经是完美保密方案中最优的了。因此其他宣称找到了突破一次一密更短的密钥的加密方案是完美保密的都是错误的。

# 2.3 香农定理（Shannon's Theorem）

定理
当明文空间=密钥空间=密文空间时，当且仅当：
1. 每个密钥k被选择的概率是**相等**的，即$P(k)=1/|K|$;
2. 对任意$m\in M\text{和}c\in C$，存在唯一密钥$k\in K$与之对应
那么这个方案是完美保密的。

使用香农定理的前提是明文空间=密钥空间=密文空间
香农定理可以用来判定一个给定的方案是否完美保密
