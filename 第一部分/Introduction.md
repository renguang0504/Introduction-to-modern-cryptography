# 1.1 密码学和现代密码学

> **核心问题：什么是密码学？**

1. 从概念上来界定
	《简明牛津英语词典》(第9版)将密码学定义为"书写或求解代码的艺术"。——这个定义在历史上是准确的（知道20世纪晚期，密码学在很大程度上依然是一门艺术）
	
	但是现在的密码学包含的内容太多了，远不是原来定义的那样。
	
	简单来说，现代密码学是一门涉及数据信息安全、系统和对抗攻击的分布式计算的数学技术研究。


2. 时间分水岭
	20世纪70-80年代，密码学这种“艺术性”发生的根本性的变化。（因为有新的理论的产生）使得密码学开始作为一门科学和数学学科的研究变得严谨。

3. 应用场景不同
	经典密码学（20世纪80年代以前）：密码学的服务对象是军事组织和政府。
	
	现在密码无处不在。
	
	简而言之，密码学已经从**一组启发式**的技术，用于确保少数小众应用的秘密通信，成为了一门科学，普通人也能广泛地使用。

---

上述的论述只是对古典密码学的一个非正式的讨论，让我们大概有一个印象和了解，要想了解这段历史应该去看相应的参考文献。

---

我们上述的讨论并没有真正地解决==什么是密码学==，这个核心的问题。这个问题可能一时间不能够给出一个完整且满意地回答，当我们学习完这本书之后再来回答这个问题。

但在这里我们可以先给他做一个==可能不那么准确的定义==，方便我们后续的一个理解。

>**什么是密码学？**
>
>**密码学 (Cryptography)** 是研究信息**机密性、完整性、实体认证及不可否认性**的科学与技术。 它以数学（尤其是数论、概率论）为基础，通过对信息进行**变换**，确保信息在存储或传输过程中，即便被第三方截获，也无法提取有效内容或进行恶意篡改。
>
>密码学真正迷人的地方在于：**它用确定性的数学，在不确定的网络世界里构建了信任。**


---

# 1.2 私钥加密设置

>**同样地，核心问题：什么是私钥？什么是私钥加密设置？**

## 1.2.1 引言
古典密码学：
	致力于设计和使用密码（或密码系统），使双方能够在传递消息时，将这些消息隐藏于能够监听其间所有通信的窃听者视线之外。
	简单来说就是，设计一种只有我们双方能看懂的密码。哪怕是有敌手，要么敌手监听不到，要么监听了但不知道我的具体内容是什么。

==所有经典加密方案的安全性都依赖一个秘密，即密钥。密钥是通信双方事先共享的，而敌手不知道的。==

由上述密钥的一个概念，引出我们**私钥设置**

>**私钥设置**：通信双方预先==共享==某些秘密的信息，这种设置被称为私钥（或共享密钥/秘密密钥）设置。
>
>**问题**：共享那些信息？为什么共享的秘密信息可以作为我们所谓的私钥？使用私钥如何对信息完成的加密？如何实现这个共享过程？怎么保证这个共享的过程时安全可信的？


## 1.2.2 私钥加密过程
- 私钥加密的过程
	在上述我们传递消息的这个背景下（信息传递的双方，以及双方通信过程中有敌手）
	
	首先，双方想要安全通信的时，会事先共享一个只有双方知道的密钥，并使用这个密钥。
	
	通信时，一方可使用共享密钥对消息（或明文）进行加密（即“扰码”），从而生成密文并发送给接收方。接收方使用相同的密钥对密文进行解密（即“解扰”），最终还原原始消息。
	
	==同一密钥==用于将明文转换为密文并反向转换；因此该设置也被称为==对称密钥设置==，其对称性体现在双方持有相同的密钥用于加密和解密。这与非对称加密（或称公钥加密，详见第11章）形成对比——后者在加密和解密过程中使用不同的密钥。

>**为什么要加密？**
>
>加密的目标是防止监听者通过监控通信信道并观察密文来窥探明文内容。

## 1.2.3**私钥密码学的典型应用场景**

两大典型场景
	1.通信双方处于空间隔离状态；
		![[私钥密码学典型应用场景1.png]]
	2.同一主体在不同时间点与自身进行通信。
		![[私钥密码学应用场景2.png]]

## 1.2.4 私钥加密的语法

严格来说，私钥加密方案通过指定消息空间M及三种算法来定义：密钥生成过程（Gen）、加密过程（Enc）和解密过程（Dec）。消息空间M定义了“合法”消息的集合，即该方案支持的消息类型。

- 密钥生成算法Gen是一种**概率算法**，它输出一个根据某种分布选择的密钥k。密钥生成算法输出的所有可能的密钥的集合称为密钥空间，记为K。通常，Gen只是从密钥空间中**均匀**地选择一个密钥
	
- 加密算法Enc将密钥k和消息m作为输入，输出密文c。我们用Enck ( m )表示用密钥k对明文m的加密。
	
- 解密算法Dec将密钥k和密文c作为输入，输出明文m。我们用Deck ( c )表示用密钥k对密文c进行解密。

==一个加密方案必须满足以下正确性要求==：对于Gen输出的每一个密钥k和每一个消息$m∈M$，都有
$$Dec_k\left( Enc_k\left( m \right) \right) =m$$
简单来说：加密一个消息，然后使用相同的密钥解密得到的密文产生原始消息。

## 1.2.5 Keys and Kerckhoffs’ principle

>**为了安全和保密，是否需要将加密方案的所有细节进行保密？**

答案是否定的。荷兰密码学家奥古斯特·柯克霍夫（Auguste Kerckhoffs）在 1883 年提出一个原则。

柯克霍夫原则可以简述为：

> **“一个密码系统的安全性不应依赖于算法的保密，而应仅仅依赖于密钥（Key）的保密。”**

通俗来说：**即使敌人拿到了你的加密机器、看到了你的源代码、彻底弄清了你的加密逻辑，只要他没有那把特定的“钥匙”，他就依然无法破解你的信息。**

**柯克霍夫原则为什么是正确的呢？**
1. **秘密难守，密钥易换** 
	维护一个短密钥的保密性要比保密一个(更复杂的)加密方案要容易得多。总之，简单地假设加密方案将保持机密性是不现实的。
	
	想象一下，你家里装了一扇由“绝密大师”设计的防盗门。
	
	**如果不遵守柯克霍夫原则（隐晦式安全）：**  
    大师告诉你：“这扇门没有钥匙，但我在门框的某个隐蔽角落装了个暗扣，你按一下门就开了。千万别告诉别人暗扣在哪里。”
    
    - **风险：** 一旦小偷通过偷窥、或者收买了大师的徒弟知道了暗扣的位置，这扇门就彻底废了。你必须把整扇门拆下来，换个新的设计。这不仅贵，而且非常麻烦。
        
	**如果遵守柯克霍夫原则：**  
    大师给你装了一扇标准的防盗门，内部的锁芯结构、齿轮咬合原理全世界都知道（甚至小偷都看过这扇门的蓝图）。但是，这扇门需要一把复杂的**钥匙**才能打开。
    
    - **优势：** 就算小偷完全知道这门是怎么造的，没有钥匙他也打不开。如果你的钥匙丢了，或者你觉得钥匙泄露了，你只需要**换一把锁芯和钥匙**（甚至只换钥匙），而不需要把整扇门拆了。
    
	
	**结论：** 算法（门的设计）一旦部署，就像门一样很难更换；而密钥（钥匙）只是一串数据，随时可以生成新的。**把安全性寄托在一个容易更换的东西上，远比寄托在一个难以更换的大系统上要明智得多。**

2. **只有公开，才能最强（由于“找茬”的人多了）**
	这是柯克霍夫原则最强大的理由：**众人的智慧胜过封闭的自负。**
	- **封闭的算法：**  
    如果你自己关起门来发明了一套“只有我知道”的加密算法，你可能觉得自己是个天才。但是，可能只有你和你的几个同事检查过它。人类是会犯错的，也许你的算法里有个致命的逻辑漏洞（Bug），你自己没发现。等到黑客发现了这个漏洞，你的系统就崩溃了。
    
	- **公开的算法：**  
    现在的国际标准算法（比如我们每天上网用的 AES 算法），在确立之前是向全世界公开征集的。这意味着，全世界最顶尖的数学家、密码学家、黑客都在没日没夜地攻击它、研究它、试图破解它。
    
    - 如果在这种强度的“群殴”下，这个算法依然屹立不倒，我们才有理由相信它是真的安全。
        
	
	**结论：** 一个公开的算法，经过了全球专家的“体检”和“千锤百炼”，肯定比你自己偷偷写出来的算法要强壮得多。**不被知晓的漏洞才是最可怕的，公开能让漏洞无处遁形。**

3. 敌人总会知道（逆向工程的存在）
	在战争或商业竞争中，永远不要低估对手的能力。
	
	- 如果你把加密算法写在软件代码里，黑客可以反编译代码。
    
	- 如果你把加密算法做成芯片，对手可以买来你的设备，切开芯片用显微镜研究电路。
    
	
	历史上有无数次教训证明，试图通过“隐藏工作原理”来保密，最终都被破解了（比如二战时期德国的 Enigma 密码机，虽然德国人极力保密机器结构，但盟军最终还是搞到了机器并分析出了原理）。
	
	**结论：** **假设敌人已经偷到了你的设备和代码**，这是最坏的打算，也是最保险的假设。在这个前提下，如果你的系统依然安全，那才是真的安全。

>**总结**
柯克霍夫原则之所以正确，是因为它承认了现实世界的残酷：
	1. **秘密（算法）是守不住的**，总会被人逆向分析出来。
	2. **更换系统的成本太高**，而更换密钥的成本几乎为零。
	3. **公开接受检验**才能造就最坚固的盾牌。



---

# 1.3 历史密码及其破译

了解“经典密码学”是为了：1.呈现启发式密码学的缺陷；2.证明实现安全加密的简单方法往往难以奏效。进而，阐述密码学的若干原理。

后续的笔记中：小写字母表示**明文(plaintext)**，大写字母表示**密文(ciphertext)**

- **凯撒密码**
	最古老的密码之一，是一种**替换加密**技术
	
	它的原理非常简单：**把字母表中的每一个字母，按照固定的数量向后（或向前）移动。**
	
	**明文：** 你原本想写的信息。
	**密钥（Key）：** ==移动的步数==。
	
	最经典的凯撒密码（当年凯撒大帝本人用的）是**向后位移 3 位**。
	
	让我们来看看这个映射关系：
	
	**A** 变成了 **D** （A -> B -> C -> D）
    
	**B** 变成了 **E**
    
	**C** 变成了 **F**
    
	...
    
	**X** 变成了 **A** （转了一圈回到头部）
	
	**Y** 变成了 **B**
    
    **Z** 变成了 **C**
    
	
	**实战演示：**
	**明文：** HELLO (你好)
	**加密后：** KHOOR

- **移位密码（Shift Cipher）**
	  
	凯撒密码其实就是一种**移位密码**
	
	1. 核心原理：转轮盘
		想象把26个英文字母写在一个圆盘上。
		**密钥**：密钥就是一个**0到25之间的数字**。这个数字决定了你要把字母表“转动”多少格。
	2. 三个步骤
		**第一步：生成密钥 (Gen)**
			随机选一个 0 到 25 之间的数字作为**密钥**$k$
		**第二步：加密 (Enc)**
			拿到一段明文（比如 "hello"），把每个字母往后**推 $k$位**
		**第三步：解密 (Dec)**
			拿到密文，把每个字母往前推$k$位，就能还原成原来的字母。
	3. 数学表达
		$a=0,\ b=1,…,z=25$
		加密公式：$$c_i=\left( m_i+k \right) \ mod\ 26$$
		mod 26：除以26取余数
		
		解密公式：$$m_i​=\left( c_i​−k \right) \ mod\ 26$$
		上述的这种加密方式，即使我们在不知到k的情况下也是可以破解的，k的取值只有26个。我们可以通过尝试所有可能的密钥进行共计（暴力破解或穷举搜索攻击）
		


	





